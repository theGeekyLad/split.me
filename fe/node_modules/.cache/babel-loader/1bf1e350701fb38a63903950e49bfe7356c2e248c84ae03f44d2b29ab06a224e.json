{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildSectionsFromFormat = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _useField = require(\"./useField.utils\");\nconst expandFormat = ({\n  adapter,\n  format\n}) => {\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = adapter.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = adapter.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the component.');\n    }\n  }\n  return nextFormat;\n};\nconst getEscapedPartsFromFormat = ({\n  adapter,\n  expandedFormat\n}) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = adapter.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(expandedFormat)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nconst getSectionPlaceholder = (adapter, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: adapter.formatByString(adapter.date(undefined, 'default'), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\nconst createSection = ({\n  adapter,\n  date,\n  shouldRespectLeadingZeros,\n  localeText,\n  localizedDigits,\n  now,\n  token,\n  startSeparator\n}) => {\n  if (token === '') {\n    throw new Error('MUI X: Should not call `commitToken` with an empty token');\n  }\n  const sectionConfig = (0, _useField.getDateSectionConfigFromFormatToken)(adapter, token);\n  const hasLeadingZerosInFormat = (0, _useField.doesSectionFormatHaveLeadingZeros)(adapter, sectionConfig.contentType, sectionConfig.type, token);\n  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n  const isValidDate = adapter.isValid(date);\n  let sectionValue = isValidDate ? adapter.formatByString(date, token) : '';\n  let maxLength = null;\n  if (hasLeadingZerosInInput) {\n    if (hasLeadingZerosInFormat) {\n      maxLength = sectionValue === '' ? adapter.formatByString(now, token).length : sectionValue.length;\n    } else {\n      if (sectionConfig.maxLength == null) {\n        throw new Error(`MUI X: The token ${token} should have a 'maxLength' property on it's adapter`);\n      }\n      maxLength = sectionConfig.maxLength;\n      if (isValidDate) {\n        sectionValue = (0, _useField.applyLocalizedDigits)((0, _useField.cleanLeadingZeros)((0, _useField.removeLocalizedDigits)(sectionValue, localizedDigits), maxLength), localizedDigits);\n      }\n    }\n  }\n  return (0, _extends2.default)({}, sectionConfig, {\n    format: token,\n    maxLength,\n    value: sectionValue,\n    placeholder: getSectionPlaceholder(adapter, localeText, sectionConfig, token),\n    hasLeadingZerosInFormat,\n    hasLeadingZerosInInput,\n    startSeparator,\n    endSeparator: '',\n    modified: false\n  });\n};\nconst buildSections = parameters => {\n  const {\n    adapter,\n    expandedFormat,\n    escapedParts\n  } = parameters;\n  const now = adapter.date(undefined);\n  const sections = [];\n  let startSeparator = '';\n\n  // This RegExp tests if the beginning of a string corresponds to a supported token\n  const validTokens = Object.keys(adapter.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first\n\n  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;\n  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);\n  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);\n  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n  let i = 0;\n  while (i < expandedFormat.length) {\n    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];\n\n    // The first word in the format is only composed of tokens.\n    // We extract those tokens to create a new sections.\n    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {\n      let word = firstWordInFormat;\n      while (word.length > 0) {\n        const firstWord = regExpFirstTokenInWord.exec(word)[1];\n        word = word.slice(firstWord.length);\n        sections.push(createSection((0, _extends2.default)({}, parameters, {\n          now,\n          token: firstWord,\n          startSeparator\n        })));\n        startSeparator = '';\n      }\n      i += firstWordInFormat.length;\n    }\n    // The remaining format does not start with a token,\n    // We take the first character and add it to the current section's end separator.\n    else {\n      const char = expandedFormat[i];\n\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;\n      if (!isEscapeBoundary) {\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n          sections[sections.length - 1].isEndFormatSeparator = true;\n        }\n      }\n      i += 1;\n    }\n  }\n  if (sections.length === 0 && startSeparator.length > 0) {\n    sections.push({\n      type: 'empty',\n      contentType: 'letter',\n      maxLength: null,\n      format: '',\n      value: '',\n      placeholder: '',\n      hasLeadingZerosInFormat: false,\n      hasLeadingZerosInInput: false,\n      startSeparator,\n      endSeparator: '',\n      modified: false\n    });\n  }\n  return sections;\n};\nconst postProcessSections = ({\n  isRtl,\n  formatDensity,\n  sections\n}) => {\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\nconst buildSectionsFromFormat = parameters => {\n  let expandedFormat = expandFormat(parameters);\n  if (parameters.isRtl && parameters.enableAccessibleFieldDOMStructure) {\n    expandedFormat = expandedFormat.split(' ').reverse().join(' ');\n  }\n  const escapedParts = getEscapedPartsFromFormat((0, _extends2.default)({}, parameters, {\n    expandedFormat\n  }));\n  const sections = buildSections((0, _extends2.default)({}, parameters, {\n    expandedFormat,\n    escapedParts\n  }));\n  return postProcessSections((0, _extends2.default)({}, parameters, {\n    sections\n  }));\n};\nexports.buildSectionsFromFormat = buildSectionsFromFormat;","map":{"version":3,"names":["_interopRequireDefault","require","default","Object","defineProperty","exports","value","buildSectionsFromFormat","_extends2","_useField","expandFormat","adapter","format","formatExpansionOverflow","prevFormat","nextFormat","Error","getEscapedPartsFromFormat","expandedFormat","escapedParts","start","startChar","end","endChar","escapedCharacters","regExp","RegExp","match","exec","push","index","lastIndex","getSectionPlaceholder","localeText","sectionConfig","sectionFormat","type","fieldYearPlaceholder","digitAmount","formatByString","date","undefined","length","fieldMonthPlaceholder","contentType","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","createSection","shouldRespectLeadingZeros","localizedDigits","now","token","startSeparator","getDateSectionConfigFromFormatToken","hasLeadingZerosInFormat","doesSectionFormatHaveLeadingZeros","hasLeadingZerosInInput","isValidDate","isValid","sectionValue","maxLength","applyLocalizedDigits","cleanLeadingZeros","removeLocalizedDigits","placeholder","endSeparator","modified","buildSections","parameters","sections","validTokens","keys","formatTokenMap","sort","a","b","regExpFirstWordInFormat","regExpWordOnlyComposedOfTokens","join","regExpFirstTokenInWord","getEscapedPartOfCurrentChar","i","find","escapeIndex","escapedPartOfCurrentChar","isEscapedChar","firstWordInFormat","slice","test","word","firstWord","char","isEscapeBoundary","isEndFormatSeparator","postProcessSections","isRtl","formatDensity","map","section","cleanSeparator","separator","cleanedSeparator","includes","enableAccessibleFieldDOMStructure","split","reverse"],"sources":["/home/thegeekylad/Projects/Projects/split.me/node_modules/@mui/x-date-pickers/internals/hooks/useField/buildSectionsFromFormat.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildSectionsFromFormat = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _useField = require(\"./useField.utils\");\nconst expandFormat = ({\n  adapter,\n  format\n}) => {\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = adapter.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = adapter.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the component.');\n    }\n  }\n  return nextFormat;\n};\nconst getEscapedPartsFromFormat = ({\n  adapter,\n  expandedFormat\n}) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = adapter.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(expandedFormat)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nconst getSectionPlaceholder = (adapter, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: adapter.formatByString(adapter.date(undefined, 'default'), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\nconst createSection = ({\n  adapter,\n  date,\n  shouldRespectLeadingZeros,\n  localeText,\n  localizedDigits,\n  now,\n  token,\n  startSeparator\n}) => {\n  if (token === '') {\n    throw new Error('MUI X: Should not call `commitToken` with an empty token');\n  }\n  const sectionConfig = (0, _useField.getDateSectionConfigFromFormatToken)(adapter, token);\n  const hasLeadingZerosInFormat = (0, _useField.doesSectionFormatHaveLeadingZeros)(adapter, sectionConfig.contentType, sectionConfig.type, token);\n  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n  const isValidDate = adapter.isValid(date);\n  let sectionValue = isValidDate ? adapter.formatByString(date, token) : '';\n  let maxLength = null;\n  if (hasLeadingZerosInInput) {\n    if (hasLeadingZerosInFormat) {\n      maxLength = sectionValue === '' ? adapter.formatByString(now, token).length : sectionValue.length;\n    } else {\n      if (sectionConfig.maxLength == null) {\n        throw new Error(`MUI X: The token ${token} should have a 'maxLength' property on it's adapter`);\n      }\n      maxLength = sectionConfig.maxLength;\n      if (isValidDate) {\n        sectionValue = (0, _useField.applyLocalizedDigits)((0, _useField.cleanLeadingZeros)((0, _useField.removeLocalizedDigits)(sectionValue, localizedDigits), maxLength), localizedDigits);\n      }\n    }\n  }\n  return (0, _extends2.default)({}, sectionConfig, {\n    format: token,\n    maxLength,\n    value: sectionValue,\n    placeholder: getSectionPlaceholder(adapter, localeText, sectionConfig, token),\n    hasLeadingZerosInFormat,\n    hasLeadingZerosInInput,\n    startSeparator,\n    endSeparator: '',\n    modified: false\n  });\n};\nconst buildSections = parameters => {\n  const {\n    adapter,\n    expandedFormat,\n    escapedParts\n  } = parameters;\n  const now = adapter.date(undefined);\n  const sections = [];\n  let startSeparator = '';\n\n  // This RegExp tests if the beginning of a string corresponds to a supported token\n  const validTokens = Object.keys(adapter.formatTokenMap).sort((a, b) => b.length - a.length); // Sort to put longest word first\n\n  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;\n  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join('|')})*$`);\n  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join('|')})`);\n  const getEscapedPartOfCurrentChar = i => escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n  let i = 0;\n  while (i < expandedFormat.length) {\n    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i);\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const firstWordInFormat = regExpFirstWordInFormat.exec(expandedFormat.slice(i))?.[1];\n\n    // The first word in the format is only composed of tokens.\n    // We extract those tokens to create a new sections.\n    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {\n      let word = firstWordInFormat;\n      while (word.length > 0) {\n        const firstWord = regExpFirstTokenInWord.exec(word)[1];\n        word = word.slice(firstWord.length);\n        sections.push(createSection((0, _extends2.default)({}, parameters, {\n          now,\n          token: firstWord,\n          startSeparator\n        })));\n        startSeparator = '';\n      }\n      i += firstWordInFormat.length;\n    }\n    // The remaining format does not start with a token,\n    // We take the first character and add it to the current section's end separator.\n    else {\n      const char = expandedFormat[i];\n\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && escapedPartOfCurrentChar?.start === i || escapedPartOfCurrentChar?.end === i;\n      if (!isEscapeBoundary) {\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n          sections[sections.length - 1].isEndFormatSeparator = true;\n        }\n      }\n      i += 1;\n    }\n  }\n  if (sections.length === 0 && startSeparator.length > 0) {\n    sections.push({\n      type: 'empty',\n      contentType: 'letter',\n      maxLength: null,\n      format: '',\n      value: '',\n      placeholder: '',\n      hasLeadingZerosInFormat: false,\n      hasLeadingZerosInInput: false,\n      startSeparator,\n      endSeparator: '',\n      modified: false\n    });\n  }\n  return sections;\n};\nconst postProcessSections = ({\n  isRtl,\n  formatDensity,\n  sections\n}) => {\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\nconst buildSectionsFromFormat = parameters => {\n  let expandedFormat = expandFormat(parameters);\n  if (parameters.isRtl && parameters.enableAccessibleFieldDOMStructure) {\n    expandedFormat = expandedFormat.split(' ').reverse().join(' ');\n  }\n  const escapedParts = getEscapedPartsFromFormat((0, _extends2.default)({}, parameters, {\n    expandedFormat\n  }));\n  const sections = buildSections((0, _extends2.default)({}, parameters, {\n    expandedFormat,\n    escapedParts\n  }));\n  return postProcessSections((0, _extends2.default)({}, parameters, {\n    sections\n  }));\n};\nexports.buildSectionsFromFormat = buildSectionsFromFormat;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}