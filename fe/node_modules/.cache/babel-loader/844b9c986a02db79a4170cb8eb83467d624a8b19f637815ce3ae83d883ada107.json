{"ast":null,"code":"import ownerDocument from '@mui/utils/ownerDocument';\nimport { getActiveElement } from \"../../utils/utils.js\";\nexport function syncSelectionToDOM(parameters) {\n  const {\n    focused,\n    domGetters,\n    stateResponse: {\n      // States and derived states\n      parsedSelectedSections,\n      state\n    }\n  } = parameters;\n  if (!domGetters.isReady()) {\n    return;\n  }\n  const selection = ownerDocument(domGetters.getRoot()).getSelection();\n  if (!selection) {\n    return;\n  }\n  if (parsedSelectedSections == null) {\n    // If the selection contains an element inside the field, we reset it.\n    if (selection.rangeCount > 0 && domGetters.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n      selection.removeAllRanges();\n    }\n    if (focused) {\n      domGetters.getRoot().blur();\n    }\n    return;\n  }\n\n  // On multi input range pickers we want to update selection range only for the active input\n  if (!domGetters.getRoot().contains(getActiveElement(domGetters.getRoot()))) {\n    return;\n  }\n  const range = new window.Range();\n  let target;\n  if (parsedSelectedSections === 'all') {\n    target = domGetters.getRoot();\n  } else {\n    const section = state.sections[parsedSelectedSections];\n    if (section.type === 'empty') {\n      target = domGetters.getSectionContainer(parsedSelectedSections);\n    } else {\n      target = domGetters.getSectionContent(parsedSelectedSections);\n    }\n  }\n  range.selectNodeContents(target);\n  target.focus();\n  selection.removeAllRanges();\n  selection.addRange(range);\n}","map":{"version":3,"names":["ownerDocument","getActiveElement","syncSelectionToDOM","parameters","focused","domGetters","stateResponse","parsedSelectedSections","state","isReady","selection","getRoot","getSelection","rangeCount","contains","getRangeAt","startContainer","removeAllRanges","blur","range","window","Range","target","section","sections","type","getSectionContainer","getSectionContent","selectNodeContents","focus","addRange"],"sources":["/home/thegeekylad/Projects/Projects/split.me/node_modules/@mui/x-date-pickers/esm/internals/hooks/useField/syncSelectionToDOM.js"],"sourcesContent":["import ownerDocument from '@mui/utils/ownerDocument';\nimport { getActiveElement } from \"../../utils/utils.js\";\nexport function syncSelectionToDOM(parameters) {\n  const {\n    focused,\n    domGetters,\n    stateResponse: {\n      // States and derived states\n      parsedSelectedSections,\n      state\n    }\n  } = parameters;\n  if (!domGetters.isReady()) {\n    return;\n  }\n  const selection = ownerDocument(domGetters.getRoot()).getSelection();\n  if (!selection) {\n    return;\n  }\n  if (parsedSelectedSections == null) {\n    // If the selection contains an element inside the field, we reset it.\n    if (selection.rangeCount > 0 && domGetters.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n      selection.removeAllRanges();\n    }\n    if (focused) {\n      domGetters.getRoot().blur();\n    }\n    return;\n  }\n\n  // On multi input range pickers we want to update selection range only for the active input\n  if (!domGetters.getRoot().contains(getActiveElement(domGetters.getRoot()))) {\n    return;\n  }\n  const range = new window.Range();\n  let target;\n  if (parsedSelectedSections === 'all') {\n    target = domGetters.getRoot();\n  } else {\n    const section = state.sections[parsedSelectedSections];\n    if (section.type === 'empty') {\n      target = domGetters.getSectionContainer(parsedSelectedSections);\n    } else {\n      target = domGetters.getSectionContent(parsedSelectedSections);\n    }\n  }\n  range.selectNodeContents(target);\n  target.focus();\n  selection.removeAllRanges();\n  selection.addRange(range);\n}"],"mappings":"AAAA,OAAOA,aAAa,MAAM,0BAA0B;AACpD,SAASC,gBAAgB,QAAQ,sBAAsB;AACvD,OAAO,SAASC,kBAAkBA,CAACC,UAAU,EAAE;EAC7C,MAAM;IACJC,OAAO;IACPC,UAAU;IACVC,aAAa,EAAE;MACb;MACAC,sBAAsB;MACtBC;IACF;EACF,CAAC,GAAGL,UAAU;EACd,IAAI,CAACE,UAAU,CAACI,OAAO,CAAC,CAAC,EAAE;IACzB;EACF;EACA,MAAMC,SAAS,GAAGV,aAAa,CAACK,UAAU,CAACM,OAAO,CAAC,CAAC,CAAC,CAACC,YAAY,CAAC,CAAC;EACpE,IAAI,CAACF,SAAS,EAAE;IACd;EACF;EACA,IAAIH,sBAAsB,IAAI,IAAI,EAAE;IAClC;IACA,IAAIG,SAAS,CAACG,UAAU,GAAG,CAAC,IAAIR,UAAU,CAACM,OAAO,CAAC,CAAC,CAACG,QAAQ,CAACJ,SAAS,CAACK,UAAU,CAAC,CAAC,CAAC,CAACC,cAAc,CAAC,EAAE;MACrGN,SAAS,CAACO,eAAe,CAAC,CAAC;IAC7B;IACA,IAAIb,OAAO,EAAE;MACXC,UAAU,CAACM,OAAO,CAAC,CAAC,CAACO,IAAI,CAAC,CAAC;IAC7B;IACA;EACF;;EAEA;EACA,IAAI,CAACb,UAAU,CAACM,OAAO,CAAC,CAAC,CAACG,QAAQ,CAACb,gBAAgB,CAACI,UAAU,CAACM,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE;IAC1E;EACF;EACA,MAAMQ,KAAK,GAAG,IAAIC,MAAM,CAACC,KAAK,CAAC,CAAC;EAChC,IAAIC,MAAM;EACV,IAAIf,sBAAsB,KAAK,KAAK,EAAE;IACpCe,MAAM,GAAGjB,UAAU,CAACM,OAAO,CAAC,CAAC;EAC/B,CAAC,MAAM;IACL,MAAMY,OAAO,GAAGf,KAAK,CAACgB,QAAQ,CAACjB,sBAAsB,CAAC;IACtD,IAAIgB,OAAO,CAACE,IAAI,KAAK,OAAO,EAAE;MAC5BH,MAAM,GAAGjB,UAAU,CAACqB,mBAAmB,CAACnB,sBAAsB,CAAC;IACjE,CAAC,MAAM;MACLe,MAAM,GAAGjB,UAAU,CAACsB,iBAAiB,CAACpB,sBAAsB,CAAC;IAC/D;EACF;EACAY,KAAK,CAACS,kBAAkB,CAACN,MAAM,CAAC;EAChCA,MAAM,CAACO,KAAK,CAAC,CAAC;EACdnB,SAAS,CAACO,eAAe,CAAC,CAAC;EAC3BP,SAAS,CAACoB,QAAQ,CAACX,KAAK,CAAC;AAC3B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}